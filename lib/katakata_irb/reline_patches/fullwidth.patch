diff --git a/lib/reline/line_editor.rb b/lib/reline/line_editor.rb
index c9e613e..6acf969 100644
--- a/lib/reline/line_editor.rb
+++ b/lib/reline/line_editor.rb
@@ -748,3 +741,3 @@ class Reline::LineEditor
       end
       str_width = dialog.width - (dialog.scrollbar_pos.nil? ? 0 : @block_elem_width)
-      str = padding_space_with_escape_sequences(Reline::Unicode.take_range(item, 0, str_width), str_width)
+      str, = Reline::Unicode.take_range(item, 0, str_width, padding: true)
@@ -793,85 +786,42 @@ class Reline::LineEditor
       end
       visual_lines.concat(vl)
     }
-    old_y = dialog.lines_backup[:first_line_started_from] + dialog.lines_backup[:started_from]
-    y = @first_line_started_from + @started_from
-    y_diff = y - old_y
-    if (old_y + old_dialog.vertical_offset) < (y + dialog.vertical_offset)
-      # rerender top
-      move_cursor_down(old_dialog.vertical_offset - y_diff)
-      start = visual_start + old_dialog.vertical_offset
-      line_num = dialog.vertical_offset - old_dialog.vertical_offset
-      line_num.times do |i|
-        Reline::IOGate.move_cursor_column(old_dialog.column)
-        if visual_lines[start + i].nil?
-          s = ' ' * old_dialog.width
-        else
-          s = Reline::Unicode.take_range(visual_lines[start + i], old_dialog.column, old_dialog.width)
-          s = padding_space_with_escape_sequences(s, old_dialog.width)
-        end
-        @output.write "\e[0m#{s}\e[0m"
-        move_cursor_down(1) if i < (line_num - 1)
-      end
-      move_cursor_up(old_dialog.vertical_offset + line_num - 1 - y_diff)
-    end
-    if (old_y + old_dialog.vertical_offset + old_dialog.contents.size) > (y + dialog.vertical_offset + dialog.contents.size)
-      # rerender bottom
-      move_cursor_down(dialog.vertical_offset + dialog.contents.size - y_diff)
-      start = visual_start + dialog.vertical_offset + dialog.contents.size
-      line_num = (old_dialog.vertical_offset + old_dialog.contents.size) - (dialog.vertical_offset + dialog.contents.size)
-      line_num.times do |i|
-        Reline::IOGate.move_cursor_column(old_dialog.column)
-        if visual_lines[start + i].nil?
-          s = ' ' * old_dialog.width
-        else
-          s = Reline::Unicode.take_range(visual_lines[start + i], old_dialog.column, old_dialog.width)
-          s = padding_space_with_escape_sequences(s, old_dialog.width)
+    old_dialog_y = dialog.lines_backup[:first_line_started_from] + dialog.lines_backup[:started_from]
+    dialog_y = @first_line_started_from + @started_from
+
+    x_range = dialog.column...dialog.column + dialog.width
+    old_x_range = old_dialog.column...old_dialog.column + old_dialog.width
+    y_range = dialog_y + dialog.vertical_offset...dialog_y + dialog.vertical_offset + dialog.contents.size
+    old_y_range = old_dialog_y + old_dialog.vertical_offset...old_dialog_y + old_dialog.vertical_offset + old_dialog.contents.size
+
+    cursor_y = dialog_y
+    old_y_range.each do |y|
+      rerender_ranges = []
+      if y_range.cover?(y) && x_range.any?(old_x_range)
+        if old_x_range.begin < x_range.begin
+          # rerender left
+          rerender_ranges << [old_x_range.begin...[old_x_range.end, x_range.begin].min, true, false]
         end
-        @output.write "\e[0m#{s}\e[0m"
-        move_cursor_down(1) if i < (line_num - 1)
-      end
-      move_cursor_up(dialog.vertical_offset + dialog.contents.size + line_num - 1 - y_diff)
-    end
-    if old_dialog.column < dialog.column
-      # rerender left
-      move_cursor_down(old_dialog.vertical_offset - y_diff)
-      width = dialog.column - old_dialog.column
-      start = visual_start + old_dialog.vertical_offset
-      line_num = old_dialog.contents.size
-      line_num.times do |i|
-        Reline::IOGate.move_cursor_column(old_dialog.column)
-        if visual_lines[start + i].nil?
-          s = ' ' * width
-        else
-          s = Reline::Unicode.take_range(visual_lines[start + i], old_dialog.column, width)
-          s = padding_space_with_escape_sequences(s, dialog.width)
+        if x_range.end < old_x_range.end
+          # rerender right
+          rerender_ranges << [[x_range.end, old_x_range.begin].max...old_x_range.end, false, true]
         end
+      else
+        rerender_ranges << [old_x_range, true, true]
+      end
+
+      rerender_ranges.each do |range, cover_begin, cover_end|
+        move_cursor_down(y - cursor_y)
+        cursor_y = y
+        col = range.begin
+        width = range.end - range.begin
+        line = visual_lines[y + visual_start - old_dialog_y] || ''
+        s, col = Reline::Unicode.take_range(line, col, width, cover_begin: cover_begin, cover_end: cover_end, padding: true)
+        Reline::IOGate.move_cursor_column(col)
         @output.write "\e[0m#{s}\e[0m"
-        move_cursor_down(1) if i < (line_num - 1)
-      end
-      move_cursor_up(old_dialog.vertical_offset + line_num - 1 - y_diff)
-    end
-    if (old_dialog.column + old_dialog.width) > (dialog.column + dialog.width)
-      # rerender right
-      move_cursor_down(old_dialog.vertical_offset + y_diff)
-      width = (old_dialog.column + old_dialog.width) - (dialog.column + dialog.width)
-      start = visual_start + old_dialog.vertical_offset
-      line_num = old_dialog.contents.size
-      line_num.times do |i|
-        Reline::IOGate.move_cursor_column(old_dialog.column + dialog.width)
-        if visual_lines[start + i].nil?
-          s = ' ' * width
-        else
-          s = Reline::Unicode.take_range(visual_lines[start + i], old_dialog.column + dialog.width, width)
-          rerender_width = old_dialog.width - dialog.width
-          s = padding_space_with_escape_sequences(s, rerender_width)
-        end
-        Reline::IOGate.move_cursor_column(dialog.column + dialog.width)
-        @output.write "\e[0m#{s}\e[0m"
-        move_cursor_down(1) if i < (line_num - 1)
       end
-      move_cursor_up(old_dialog.vertical_offset + line_num - 1 + y_diff)
     end
+    move_cursor_up(cursor_y - dialog_y)
     Reline::IOGate.move_cursor_column((prompt_width + @cursor) % @screen_size.last)
   end
 
@@ -912,9 +862,8 @@ class Reline::LineEditor
     dialog_vertical_size = dialog.contents.size
     dialog_vertical_size.times do |i|
       if i < visual_lines_under_dialog.size
-        Reline::IOGate.move_cursor_column(dialog.column)
-        str = Reline::Unicode.take_range(visual_lines_under_dialog[i], dialog.column, dialog.width)
-        str = padding_space_with_escape_sequences(str, dialog.width)
+        str, start_pos = Reline::Unicode.take_range(visual_lines_under_dialog[i], dialog.column, dialog.width, cover_begin: true, cover_end: true, padding: true)
+        Reline::IOGate.move_cursor_column(start_pos)
         @output.write "\e[0m#{str}\e[0m"
       else
         Reline::IOGate.move_cursor_column(dialog.column)
diff --git a/lib/reline/unicode.rb b/lib/reline/unicode.rb
index 6000c9f..03074dd 100644
--- a/lib/reline/unicode.rb
+++ b/lib/reline/unicode.rb
@@ -194,17 +194,21 @@ class Reline::Unicode
   end
 
   # Take a chunk of a String cut by width with escape sequences.
-  def self.take_range(str, start_col, max_width, encoding = str.encoding)
+  def self.take_range(str, start_col, width, encoding: str.encoding, cover_begin: false, cover_end: false, padding: false)
     chunk = String.new(encoding: encoding)
     total_width = 0
     rest = str.encode(Encoding::UTF_8)
     in_zero_width = false
+    chunk_start_col = nil
+    chunk_end_col = nil
     rest.scan(WIDTH_SCANNER) do |gc|
       case
       when gc[NON_PRINTING_START_INDEX]
         in_zero_width = true
+        chunk << NON_PRINTING_START
       when gc[NON_PRINTING_END_INDEX]
         in_zero_width = false
+        chunk << NON_PRINTING_END
       when gc[CSI_REGEXP_INDEX]
         chunk << gc[CSI_REGEXP_INDEX]
       when gc[OSC_REGEXP_INDEX]
@@ -215,13 +219,31 @@ class Reline::Unicode
           chunk << gc
         else
           mbchar_width = get_mbchar_width(gc)
+          prev_width = total_width
           total_width += mbchar_width
-          break if (start_col + max_width) < total_width
-          chunk << gc if start_col < total_width
+          break if !cover_end && total_width > start_col + width
+          if cover_begin ? start_col < total_width : start_col <= prev_width
+            chunk << gc
+            chunk_start_col ||= prev_width
+            chunk_end_col = total_width
+          end
+          break if total_width >= start_col + width
         end
       end
     end
-    chunk
+    chunk_start_col ||= start_col
+    chunk_end_col ||= start_col
+    if padding
+      if start_col < chunk_start_col
+        chunk = ' ' * (chunk_start_col - start_col) + chunk
+        chunk_start_col = start_col
+      end
+      if chunk_end_col < start_col + width
+        chunk << ' ' * (start_col + width - chunk_end_col)
+        chunk_end_col = start_col + width
+      end
+    end
+    [chunk, chunk_start_col, chunk_end_col - chunk_start_col]
   end
 
   def self.get_next_mbchar_size(line, byte_pointer)
